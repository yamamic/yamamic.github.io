<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Kazi&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="this is a website for record kazi thought and knowledge">
<meta property="og:type" content="website">
<meta property="og:title" content="Kazi&#39;s Blog">
<meta property="og:url" content="https://yamamic.github.io/index.html">
<meta property="og:site_name" content="Kazi&#39;s Blog">
<meta property="og:description" content="this is a website for record kazi thought and knowledge">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Kazi Ball">
<meta property="article:tag" content="record blog">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Kazi's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Kazi&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yamamic.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-DHCP协议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/09/DHCP%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time class="dt-published" datetime="2023-11-09T08:48:18.000Z" itemprop="datePublished">2023-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/09/DHCP%E5%8D%8F%E8%AE%AE/">DHCP协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="DHCP客户端请求IP地址的过程"><a href="#DHCP客户端请求IP地址的过程" class="headerlink" title="DHCP客户端请求IP地址的过程"></a>DHCP客户端请求IP地址的过程</h3><p>client                                               server<br>        —————————&gt; DHCP Discover<br>        DHCP Offer &lt;——————————<br>        —————————-&gt; DHCP Request<br>        DHCP ACK &lt;——————————–</p>
<ol>
<li>若客户端请求的是一个无效的或存在冲突的IP地址，则DHCP服务器可以响应一个DHCP NAK消息用于拒绝并强迫客户端释放其IP地址并获得一个新的有效的地址</li>
<li>若客户端无法得到一个新的IP地址，DHCP客户端自己会产生一个169.254.0.0&#x2F;16网段中的IP地址作为临时地址</li>
</ol>
<h3 id="租约更新流程"><a href="#租约更新流程" class="headerlink" title="租约更新流程"></a>租约更新流程</h3><ol>
<li>租约时间过去一半后，客户端向DHCP服务器发送请求，请求更新和延长当前租约。最多重发3次，如果找到了DHCP服务器，则服务器会向客户端发送一个DHCP应答消息。</li>
<li>若租约时间过去一半后，客户端未能与原DHCP服务器进行通信。等待租约时间过去3&#x2F;4，客户端会进入重绑定状态，向任何可用的DHCP服务器广播（最多3次）一个DHCP Discover消息用于更新当前IP租约</li>
<li>若租约到期客户端仍未连接到任何一台服务器，客户端必须立即停止其使用的IP地址然后重新开始获得新的IP地址租约</li>
</ol>
<h3 id="DHCP报文格式"><a href="#DHCP报文格式" class="headerlink" title="DHCP报文格式"></a>DHCP报文格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OP(1 Byte)      Htypt(1 Byte)       Hlen(1 Byte)        Hops(1 Byte)</span><br><span class="line">                        Xid(4 Bytes)</span><br><span class="line">        Secs(2 Bytes)                       Flags(2 Bytes)</span><br><span class="line">                        Ciaddr(4 Bytes)</span><br><span class="line">                        Yiaddr(4 Bytes)</span><br><span class="line">                        Siaddr(4 Bytes)</span><br><span class="line">                        Giaddr(4 Bytes)</span><br><span class="line">                        Chaddr(16 Bytes)</span><br><span class="line">                        Sname(64 Bytes)</span><br><span class="line">                        File(128 Bytes)</span><br><span class="line">                        Options(可变长度)</span><br></pre></td></tr></table></figure>
<ul>
<li>OP<p>报文操作类型。<ul>
<li>1-&gt;请求报文,包含DHCP Discover,DHCP Request,DHCP Release,DHCP Inform和DHCP Decline</li>
<li>2-&gt;应答报文,包含DHCP Offer,DHCP ACK和DHCP NAK</li>
</ul>
</p></li>
<li>Htypt<p>客户端的MAC地址了下,为1时最常见</p></li>
<li>Hlen<p>客户端的MAC地址长度</p></li>
<li>Hops<p>DHCP报文经过的DHCP中继的数目,默认为0.DHCP请求报文每经过一个DHCP中继,该字段就会增加1</p></li>
<li>Xid<p>客户端通过DHCP Discover报文发起一次IP地址请求时选择的随机数,用于标识一次IP地址请求过程.在一次请求中所有报文的Xid都是一样的.</p></li>
<li>Secs<p>DHCP客户端从获取到IP地址或者续约过程开始到现在所消耗的时间</p></li>
<li>Flags<p>标志位,只使用第0比特位,是广播应答标志位,用于标识DHCP服务器应答报文是采用单播还是广播发送.0-&gt;单播,1-&gt;广播.(在客户端正式分配了IP地址前的第一次IP地址请求过程中,所有DHCP报文都是以广播形式发送的,IP地址续约,IP地址释放的相关报文都是采用单播方式进行发送)</p></li>
<li>Ciaddr<p>DHCP客户端的IP地址.仅在DHCP服务器发送的ACK报文中显示,其他报文中显示0.</p></li>
<li>Yiaddr<p>DHCP服务器分配给客户端的IP地址.仅在DHCP服务器发送的Offer和ACK报文中显示,其他报文中显示为0.</p></li>
<li>Siaddr<p>下一个为DHCP客户端分配IP地址等信息的DHCP服务器IP地址。仅在DHCP Offer，DHCP ACK报文中显示。</p></li>
<li>Giaddr<p>DHCP客户端发出请求报文后经过的第一个DHCP中继的IP地址.如未经过DHCP中继则显示0.</p></li>
<li>Chaddr<p>DHCP客户端的MAC地址</p></li>
<li>Sname<p>为DHCP客户端分配IP地址的DHCP服务器名称(DNS域名格式).Offer和ACK报文中显示发送报文的DHCP服务器名称,其他报文显示为0.</p></li>
<li>File<p>DHCP服务器为DHCP客户端指定的启动配置文件名称及路径信息.仅在DHCP Offer报文中显示,其他报文显示为空.</p></li>
<li>Options<p>可选字段,长度可变,格式为”代码(1字节)+长度(1字节)+数据”.</p><p>示例:<ul>
<li>option(53)len(1)data(01) -&gt; 0x350101</li>
</ul>
</p></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yamamic.github.io/2023/11/09/DHCP%E5%8D%8F%E8%AE%AE/" data-id="clorxinoj000064pzdkpsedc2" data-title="DHCP协议" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-dns" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/25/dns/" class="article-date">
  <time class="dt-published" datetime="2023-08-25T02:35:57.000Z" itemprop="datePublished">2023-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/25/dns/">dns server</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="国内外公共DNS"><a href="#国内外公共DNS" class="headerlink" title="国内外公共DNS"></a>国内外公共DNS</h2><ul>
<li><p>腾讯云DNS   </p>
<ul>
<li>IPv4 DNS地址:   119.29.29.29</li>
<li>IPv6 DNS地址:   2402:4e00::</li>
<li>服务地址:   <a target="_blank" rel="noopener" href="https://www.dnspod.cn/products/publicdns">https://www.dnspod.cn/products/publicdns</a></li>
</ul>
</li>
<li><p>阿里云公共DNS</p>
<ul>
<li>IPv4 DNS地址:   223.5.5.5&#x2F;223.6.6.6</li>
<li>IPv6 DNS地址:   2400:3200::1&#x2F;2400:3200:baba::1</li>
<li>服务地址:   <a target="_blank" rel="noopener" href="https://alidns.com/">https://alidns.com</a></li>
</ul>
</li>
<li><p>百度公共DNS</p>
<ul>
<li>IPv4 DNS地址:   180.76.76.76</li>
<li>IPv6 DNS地址:   2400:da00::6666</li>
<li>服务地址:</li>
</ul>
</li>
<li><p>DNS</p>
<ul>
<li>IPv4 DNS地址:   114.114.114.114&#x2F;114.114.115.115</li>
</ul>
</li>
<li><p>OneDNS</p>
<ul>
<li>拦截版IPv4 DNS地址: 117.50.11.11&#x2F;52.80.66.66    (恶意网站拦截,广告过滤)</li>
<li>纯净版IPv4 DNS地址: 117.50.10.10&#x2F;52.80.52.52    (不进行任何拦截)</li>
<li>家庭版IPv4 DNS地址: 117.50.60.30&#x2F;52.80.60.30    </li>
<li>服务地址:   onedns.net</li>
</ul>
</li>
<li><p>谷歌公共DNS</p>
<ul>
<li>IPv4 DNS地址:   8.8.8.8&#x2F;8.8.4.4</li>
<li>服务地址:   developers.google.com&#x2F;speed&#x2F;public-dns</li>
</ul>
</li>
<li><p>Cloudflare DNS</p>
<ul>
<li>IPv4 DNS address:   1.1.1.1&#x2F;1.0.0.1</li>
<li>IPv6 DNS address:   2606:4700:4700::1111&#x2F;2606:4700:4700::1001</li>
<li>service address：   developers.google.com&#x2F;speed&#x2F;public-dns</li>
</ul>
</li>
<li><p>OpenDNS</p>
<ul>
<li>IPv4 DNS address:   208.67.222.222&#x2F;208.67.220.220</li>
<li>IPv6 DNS address:   2620:119:35::35&#x2F;2620:119:53::53</li>
<li>service address:    opendns.com&#x2F;</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yamamic.github.io/2023/08/25/dns/" data-id="cllpzx07v0000nkpzal6a6y0d" data-title="dns server" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-DHCP报文及协议/DHCP报文及协议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/18/DHCP%E6%8A%A5%E6%96%87%E5%8F%8A%E5%8D%8F%E8%AE%AE/DHCP%E6%8A%A5%E6%96%87%E5%8F%8A%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time class="dt-published" datetime="2023-08-18T01:54:10.000Z" itemprop="datePublished">2023-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/18/DHCP%E6%8A%A5%E6%96%87%E5%8F%8A%E5%8D%8F%E8%AE%AE/DHCP%E6%8A%A5%E6%96%87%E5%8F%8A%E5%8D%8F%E8%AE%AE/">DHCP报文及协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yamamic.github.io/2023/08/18/DHCP%E6%8A%A5%E6%96%87%E5%8F%8A%E5%8D%8F%E8%AE%AE/DHCP%E6%8A%A5%E6%96%87%E5%8F%8A%E5%8D%8F%E8%AE%AE/" data-id="cllfxu22e000008pzgooz041r" data-title="DHCP报文及协议" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-1905-process" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/09/1905-process/" class="article-date">
  <time class="dt-published" datetime="2023-08-08T18:14:57.000Z" itemprop="datePublished">2023-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/09/1905-process/">1905 协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1905协议"><a href="#1905协议" class="headerlink" title="1905协议"></a>1905协议</h2><ul>
<li>1905.1 CMDU<ul>
<li>承载在二层协议上，不需要IP协议栈。包含8字节头和一个TLV列表  <ul>
<li>头部信息   <img src="/pic/CMDU-head.png" alt="cmdu head"></li>
<li>TLV格式    <img src="/pic/TLV-format.png" alt="tlv format"></li>
<li>消息类型   <img src="/pic/cmdu-msgtype1.png">   
 <img src="/pic/cmdu-msgtype2.png">   
 <img src="/pic/cmdu-msgtype3.png"></li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yamamic.github.io/2023/08/09/1905-process/" data-id="cll33etaf0000gspz0z9ddbfj" data-title="1905 协议" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-vscode远程工作cpu占用率过高问题修改" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/01/vscode%E8%BF%9C%E7%A8%8B%E5%B7%A5%E4%BD%9Ccpu%E5%8D%A0%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%E9%97%AE%E9%A2%98%E4%BF%AE%E6%94%B9/" class="article-date">
  <time class="dt-published" datetime="2023-08-01T02:27:15.000Z" itemprop="datePublished">2023-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/01/vscode%E8%BF%9C%E7%A8%8B%E5%B7%A5%E4%BD%9Ccpu%E5%8D%A0%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%E9%97%AE%E9%A2%98%E4%BF%AE%E6%94%B9/">vscode远程工作cpu占用率过高问题修改</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>修改设置如下图即可<br><img src="/pic/vscode-setting.png" alt="vscode setting"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yamamic.github.io/2023/08/01/vscode%E8%BF%9C%E7%A8%8B%E5%B7%A5%E4%BD%9Ccpu%E5%8D%A0%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%E9%97%AE%E9%A2%98%E4%BF%AE%E6%94%B9/" data-id="clks0noi40007cwpz9gyb4ava" data-title="vscode远程工作cpu占用率过高问题修改" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-mapd-process" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/31/mapd-process/" class="article-date">
  <time class="dt-published" datetime="2023-07-31T01:39:36.000Z" itemprop="datePublished">2023-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/31/mapd-process/">mapd_process</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>main.c<ul>
<li>mapd_fd_wordaround  确保&#x2F;dev&#x2F;null打开且为2</li>
<li>初始化全局变量<ul>
<li>g_map_cfg_path    &#x2F;etc&#x2F;mapd_cfg.txt</li>
<li>g_map_1905_cfg_path   &#x2F;etc&#x2F;map_cfg.txt</li>
</ul>
</li>
<li>mapd_init  初始化<ul>
<li>log的初始化</li>
<li>全局变量global的初始化<ul>
<li>Certification   0</li>
<li>daemonize   0</li>
<li>ctrl_interface  “&#x2F;tmp&#x2F;mapd_ctrl”</li>
<li>clientDBname  “.&#x2F;client_db.txt”</li>
<li>mapd_debug_level</li>
<li>mapd_debug_timestamp</li>
<li>wapp_map_buffer_size  15KB</li>
<li>wapp_map_buffer   申请空间</li>
<li>ctrl_iface    初始化监听socket &#x2F;tmp&#x2F;mapd_ctrl<ul>
<li>eloop_register_read_sock(priv-&gt;sock, mapd_global_ctrl_iface_receive, global, priv); &#x2F;tmp&#x2F;mapd_ctrl</li>
</ul>
</li>
</ul>
</li>
<li>连接wapp  wapp_open_connection(“&#x2F;tmp&#x2F;wapp_ctrl”, global);<ul>
<li>eloop_register_read_sock(ctrl_conn-&gt;s, mapd_receive_from_wapp, global, ctrl_conn);</li>
</ul>
</li>
<li>注册wapp事件  wlanif_register_wapp_events</li>
<li>连接1905d _1905_open_connection  <ul>
<li>处理1905发来的消息    _1905_interface_parse_event</li>
</ul>
</li>
<li>获取wifi接口的状态填充到global</li>
<li>初始化本设备的1905信息</li>
<li>注册mapd_start_wired_iface_monitor    立刻执行    随后注册5s超时  自动识别设备为controller</li>
<li>注册topo_srv_start_1905_timer 5s超时  更新拓扑图链表，删除断联超时的拓扑节点</li>
<li>注册mapd_periodic</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yamamic.github.io/2023/07/31/mapd-process/" data-id="clks0noi00005cwpz1p9jfst7" data-title="mapd_process" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-gcc-note" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/29/gcc-note/" class="article-date">
  <time class="dt-published" datetime="2023-07-29T06:46:02.000Z" itemprop="datePublished">2023-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/29/gcc-note/">gcc-note</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yamamic.github.io/2023/07/29/gcc-note/" data-id="clks0nohy0002cwpzhyfx7rfk" data-title="gcc-note" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-makefile-note" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/29/makefile-note/" class="article-date">
  <time class="dt-published" datetime="2023-07-29T06:45:49.000Z" itemprop="datePublished">2023-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/29/makefile-note/">makefile-note</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><p>   文件名格式:Makefile makefile GNUmakefile</p>
</li>
<li><p>   规则:</p>
<ul>
<li>   由目标、目标依赖、命令三部分构成(一个规则中不一定具有所有的三个规则,目标依赖和命令都可以无)   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目标:目标依赖</span><br><span class="line">	命令</span><br><span class="line">a.out:hello.c</span><br><span class="line">	gcc -o a.out hello.c</span><br></pre></td></tr></table></figure></li>
<li>   规则可以有多个目标<br>   %.o:%.c<br>       gcc -o %.o %.c</li>
</ul>
</li>
<li><p>   make目标依赖:</p>
<ul>
<li>   make第一次编译项目会依次编译所有的源文件。修改程序后make会根据文件的时间戳判断文件是否有更新来决定是否对其进行编译。</li>
<li>   头文件依赖:<br>   一般不将头文件添加至规则的目标依赖列表。这样如果头文件改变,不会重新编译源文件。可以将头文件添加至依赖目标中,但是<br>   这样过于繁琐。可以使用gcc -MM自动生成头文件依赖关系。</li>
</ul>
</li>
<li><p>   命令:</p>
<ul>
<li>   make对于规则中每一个命令会开一个进程执行,每条命令执行完make会检测其返回码。命令返回成功,则make继续执行下一个命令；命令<br>   执行失败,make终止执行当前的规则,退出编译。</li>
</ul>
</li>
<li><p>   变量:</p>
<ul>
<li>   定义变量:val &#x3D; test</li>
<li>   引用变量:$(val)</li>
<li>   变量赋值:<ul>
<li>   条件赋值:?&#x3D;	(如果变量未定义,则直接赋值,否则什么也不作)</li>
<li>   追加赋值:+&#x3D;	(OBJS &#x3D; hello.o  OBJS+&#x3D; module.o 相当于 OBJS &#x3D; hello.o module.o)</li>
</ul>
</li>
<li>   立即变量::&#x3D;</li>
<li>   延迟展开变量:&#x3D;</li>
</ul>
</li>
<li><p>   变量替换:</p>
<ul>
<li><p>   使用指定字符串替换变量中的字符串</p>
<ul>
<li>   .PHONY: all<br>   SRC :&#x3D; main.c sub.c<br>   OBJ :&#x3D; $(SRC:.c&#x3D;.o)<br>   替换后结果为 OBJ :&#x3D; main.o sub.o</li>
</ul>
</li>
<li><p>   模式匹配替换</p>
<ul>
<li><p>   使用匹配符%匹配变量,使用%保留变量中的指定字符串然后其他部分使用指定字符串代替<br>   SRC &#x3D; main.c sub.c<br>   OBJ &#x3D; $(SRC:%.c&#x3D;%.o)</p>
<p>   test: 1.o 2.o 3.o<br>   %.o:%.c</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>   环境变量</p>
<ul>
<li>   系统环境变量<ul>
<li>   $(SHELL)	&#x2F;bin&#x2F;sh</li>
<li>   $(MAKE)		make</li>
</ul>
</li>
</ul>
</li>
<li><p>   export传递变量</p>
<ul>
<li>   在shell环境下使用export命令相当于将变量声明为系统环境变量,make解析Makefile时会自动引入系统环境变量</li>
</ul>
</li>
<li><p>   Makefile递归执行</p>
<ul>
<li>   make -C subdir1	subdir2	subdir3<br>   相当于<br>   cd subdir1 &amp;&amp; $(MAKE)<br>   cd subdir2 &amp;&amp; $(MAKE)<br>   cd subdir3 &amp;&amp; $(MAKE)</li>
</ul>
</li>
<li><p>   override:</p>
<ul>
<li><p>   如果不希望命令行指定的变量值替代在Makefile中的原来定义,可以用override对变量进行声明<br>   override web &#x3D; <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a><br>   all:<br>       @echo “web &#x3D; $(web)”<br><br>   使用make web&#x3D;<a target="_blank" rel="noopener" href="http://www.taobao.com将始终输出web/">www.taobao.com将始终输出web</a> &#x3D; <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></p>
</li>
<li><p>   如果编译程序时,无论在命令行指定什么参数,编译器在编译时必须打开-w选项,那么Makefile中CFLAGS应该这样定义<br>   override CFLAGS +&#x3D; -w<br>   当执行make CFLAGS&#x3D;-g时,CFLAGS就变成了-g -w</p>
</li>
</ul>
</li>
<li><p>   条件判断:</p>
<ul>
<li><p>   ifeq ($(val1),$(val2))<br>   else<br>   endif<br>   用于判断两个变量是否相等<br>   ifneq和ifeq恰恰相反</p>
<p>   ifdef mode<br>   else<br>   endif<br>   用于判断变量mode是否被定义<br>   ifndef和ifdef恰恰相反</p>
</li>
</ul>
</li>
<li><p>   函数:</p>
<ul>
<li><p>   内嵌函数:可直接调用</p>
<ul>
<li><p>   subst:		替换字符串	$(subst .c,.o,$dir)	:subst把$(dir)中名称转为xx.o</p>
</li>
<li><p>   patsubst:	替换通配符	$(patsubst %.c,%.o,$(dir))	:	patsubst把$(dir)中的变量符合后缀为.c的全部替换为.o</p>
</li>
<li><p>   wildcard:	扩展通配符	src &#x3D; $(wildcard <em>.c .&#x2F;sub&#x2F;</em>.c)	:	wildcard把指定目录.&#x2F;和.&#x2F;sub&#x2F;下所有后缀是.c的文件全部展开</p>
</li>
<li><p>   notdir:		去除路径	dir &#x3D; $(notdir $(src))	:	notdir把展开的文件去掉路径信息</p>
</li>
<li><p>   strip:		去空格函数,包括开头,结尾的空格,多个空格,tab等不可显示的字符	</p>
<ul>
<li><pre><code>              STR =   hello  a  b c 
</code></pre>
</li>
<li><pre><code>              STRIP_STR = $(strip $(STR))		:	STRIP_STR相当于hello a b c
</code></pre>
</li>
</ul>
</li>
<li><p>   findstring:	查找字符串	$(findstring FIND,IN)	:	在字符串IN中查找“FIND”字符串,找到则返回字符串FIND,否则返回空</p>
</li>
<li><p>   filter:	过滤指定的字符串	$(filter PATTERN…,TEXT)	:	过滤TEXT中不符合PATTERN模式的单词</p>
<ul>
<li><pre><code>        FILE = a.c b.h c.s d.cpp   
</code></pre>
</li>
<li><pre><code>        SRC = $(filter %.c, $(FILE))		:	SRC = a.c
</code></pre>
</li>
</ul>
</li>
<li><p>   filter-out:	过滤掉符合PATTERN模式的单词</p>
</li>
<li><p>   sort:	单词排序</p>
</li>
<li><p>   word:	$(word N,TEXT)	:	从字符串TEXT中按照指定的数目N取单词</p>
</li>
<li><p>   wordlist:	$(wordlist N,M,TEXT)	:	从字符串TEXT中取N到M之间的字符串</p>
</li>
<li><p>   words:	统计字符串中单词数量</p>
</li>
<li><p>   firstword:	取字符串中首个单词</p>
</li>
<li><p>   dir:	$(dir Names..)	:	取路径中的目录</p>
</li>
<li><p>   notdir:	$(notdir Names..)	:	取路径中的文件名</p>
</li>
<li><p>   suffx:	$(suffx Names..)	:	取路径中的文件名后缀</p>
</li>
<li><p>   basename:	取文件名前缀</p>
</li>
<li><p>   addsuffx:	$(addsuffx SUFFIX,Names..)	:	加后缀</p>
</li>
<li><p>   addprefix:	加前缀</p>
</li>
<li><p>   join:	将字符串中单词依次连接</p>
</li>
<li><p>   foreach:	$(foreach VAR,LIST,TEXT)	:	foreach函数的工作过程是:把LIST中使用空格分割的单词依次取出并赋值给变量VAR,<br>                                           然后执行TEXT表达式。重复这个过程,直到遍历完LIST中的最后一个单词。函数的返回值是TEXT多次计算的结果。</p>
</li>
<li><p>   if:		</p>
<ul>
<li>$(if CONDITION,THEN-PART)</li>
<li>   $(if CONDITION,THEN-PART[,ELSE-PART])	:	if 函数的第一个参数 CONDITION表示条件判断,展开后如果非空,则条件为真,执行 THEN-PART部分；否则,如果有ELSE-PART部分,则执行ELSE-PART部分</li>
</ul>
</li>
<li><p>   origin:	顾名思义,origin函数的作用就是告诉你,你所关注的一个变量是从哪里来的。函数的使用格式为:</p>
<ul>
<li><pre><code>  $(origin &lt;variable&gt;)
   如果变量没有定义,origin函数的返回值为:undefined,不同的返回值代表变量的类型不同。常见的返回值如下;
</code></pre>
</li>
<li><pre><code>  default:变量是一个默认的定义,比如 CC 这个变量
</code></pre>
</li>
<li><pre><code>  file:这个变量被定义在Makefile中
</code></pre>
</li>
<li><pre><code>  command line:这个变量是被命令行定义的
</code></pre>
</li>
<li><pre><code>  override:这个变量是被override指示符重新定义过的
</code></pre>
</li>
<li><pre><code>  automatic:一个命令运行中的自动化变量
</code></pre>
</li>
</ul>
</li>
<li><p>   shell:	$(shell pwd)	:	用于在Makefile中运行shell命令</p>
</li>
</ul>
</li>
<li><p>   自定义函数:需要用call函数间接调用,参数间用空格隔开 	$(call func,hello world)</p>
<ul>
<li>   define 函数名<br>   函数体</li>
<li>   endef<br>   给函数传递的参数在函数中使用$(0),$(1)引用,分别表示第一个参数,第二个参数</li>
</ul>
</li>
</ul>
</li>
<li><p>   通配符:	和shell一样</p>
</li>
<li><p>   自动变量</p>
<ul>
<li>   $+<ul>
<li>   @	:	目标</li>
<li>   ^	:	目标所有依赖</li>
<li>   &lt;	:	目标依赖列表中第一个依赖</li>
<li>   ？	:	所有目标依赖中被修改过的文件</li>
</ul>
</li>
</ul>
</li>
<li><p>   $(MAKE)	:	make</p>
</li>
<li><p>   make -C	dir:	为make提供不同的目录,make首先切换到dir目录下,然后执行make,然后再切换回来</p>
<ul>
<li><pre><code>-f	mymakefile	:	将mymakefile视为Makefile
</code></pre>
</li>
<li><pre><code>-d 	:	打印调试信息
</code></pre>
</li>
<li><pre><code>-B		:	强制编译所有的目标文件和最终的执行文件
</code></pre>
</li>
<li><pre><code>-p		:	查看所有预定义的变量的当前值
</code></pre>
</li>
<li><pre><code>-j4	:	指定同时执行的命令数目为4,存在多个-j目标时,最后一个目标指定的jobs有效
</code></pre>
</li>
</ul>
</li>
<li><p>   @cmd	:	不会打印正在执行的cmd,只会执行cmd并输出执行cmd后得到的结果</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yamamic.github.io/2023/07/29/makefile-note/" data-id="clks0nohz0003cwpz7an63l1k" data-title="makefile-note" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-inotify" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/29/inotify/" class="article-date">
  <time class="dt-published" datetime="2023-07-29T06:45:37.000Z" itemprop="datePublished">2023-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/29/inotify/">inotify</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="inotify是一种文件系统的变化通知机制-如文件增加、删除事件可以立刻让用户态得知-由著名的桌面搜索引擎项目beagle引入-并在Gamin等项目中被应用"><a href="#inotify是一种文件系统的变化通知机制-如文件增加、删除事件可以立刻让用户态得知-由著名的桌面搜索引擎项目beagle引入-并在Gamin等项目中被应用" class="headerlink" title="inotify是一种文件系统的变化通知机制,如文件增加、删除事件可以立刻让用户态得知.由著名的桌面搜索引擎项目beagle引入,并在Gamin等项目中被应用."></a>inotify是一种文件系统的变化通知机制,如文件增加、删除事件可以立刻让用户态得知.由著名的桌面搜索引擎项目beagle引入,并在Gamin等项目中被应用.</h3><h3 id="inotify-是为替代-dnotify-而设计的-它克服了-dnotify-的缺陷-提供了更好用的-简洁而强大的文件变化通知机制："><a href="#inotify-是为替代-dnotify-而设计的-它克服了-dnotify-的缺陷-提供了更好用的-简洁而强大的文件变化通知机制：" class="headerlink" title="inotify 是为替代 dnotify 而设计的,它克服了 dnotify 的缺陷,提供了更好用的,简洁而强大的文件变化通知机制："></a>inotify 是为替代 dnotify 而设计的,它克服了 dnotify 的缺陷,提供了更好用的,简洁而强大的文件变化通知机制：</h3><ol>
<li><p>Inotify 不需要对被监视的目标打开文件描述符,而且如果被监视目标在可移动介质上,那么在 umount 该介质上的文件系统后,被监视目标对应的 watch 将被自动删除,并且会产生一个 umount 事件。</p>
</li>
<li><p>Inotify 既可以监视文件,也可以监视目录。</p>
</li>
<li><p>Inotify 使用系统调用而非 SIGIO 来通知文件系统事件。</p>
</li>
<li><p>Inotify 使用文件描述符作为接口,因而可以使用通常的文件 I&#x2F;O 操作select 和 poll 来监视文件系统的变化。</p>
</li>
</ol>
<ul>
<li><p>Inotify 可以监视的文件系统事件包括：</p>
<ul>
<li><p>IN_ACCESS,即文件被访问</p>
</li>
<li><p>IN_MODIFY,文件被 write</p>
</li>
<li><p>IN_ATTRIB,文件属性被修改,如 chmod、chown、touch 等</p>
</li>
<li><p>IN_CLOSE_WRITE,可写文件被 close</p>
</li>
<li><p>IN_CLOSE_NOWRITE,不可写文件被 close</p>
</li>
<li><p>IN_OPEN,文件被 open</p>
</li>
<li><p>IN_MOVED_FROM,文件被移走,如 mv</p>
</li>
<li><p>IN_MOVED_TO,文件被移来,如 mv、cp</p>
</li>
<li><p>IN_CREATE,创建新文件</p>
</li>
<li><p>IN_DELETE,文件被删除,如 rm</p>
</li>
<li><p>IN_DELETE_SELF,自删除,即一个可执行文件在执行时删除自己</p>
</li>
<li><p>IN_MOVE_SELF,自移动,即一个可执行文件在执行时移动自己</p>
</li>
<li><p>IN_UNMOUNT,宿主文件系统被 umount</p>
</li>
<li><p>IN_CLOSE,文件被关闭,等同于(IN_CLOSE_WRITE | IN_CLOSE_NOWRITE)</p>
</li>
<li><p>IN_MOVE,文件被移动,等同于(IN_MOVED_FROM | IN_MOVED_TO)</p>
</li>
</ul>
</li>
<li><p>注：上面所说的文件也包括目录</p>
</li>
<li><p>头文件: #include&lt;sys&#x2F;inotify.h&gt;</p>
</li>
<li><p>用户接口:</p>
<ul>
<li>int fd &#x3D; inotify_init();    创建inotify实例<ul>
<li><p>每一个 inotify 实例对应一个独立的排序的队列。</p>
</li>
<li><p>文件系统的变化事件被称做 watches 的一个对象管理,每一个 watch 是一个二元组（目标,事件掩码）,目标可以是文件或目录,事件掩码表示应用希望关注的 inotify 事件,每一个位对应一个 inotify 事件。</p>
</li>
</ul>
</li>
</ul>
<p>  Watch 对象通过 watch描述符引用,watches 通过文件或目录的路径名来添加。目录 watches 将返回在该目录下的所有文件上面发生的事件。</p>
<ul>
<li><p>int wd &#x3D; inotify_add_watch(fd, path, mask);</p>
<ul>
<li>参数介绍:<ul>
<li>fd: inotify_init()返回的文件描述符</li>
<li>path:   被监视的目标的路径名</li>
<li>mask:   事件掩码,在头文件linux&#x2F;inotify.h中定义了每一位代表的事件.可以使用同样的方式修改事件掩码,即改变希望被通知的inotify事件.</li>
<li>wd:     watch描述符</li>
</ul>
</li>
</ul>
</li>
<li><p>int ret &#x3D; inotify_rm_watch(fd, wd);</p>
<ul>
<li>参数介绍:<ul>
<li>fd: inotify_init()返回的文件描述符</li>
<li>wd: inotify_add_watch()返回的watch描述符</li>
<li>ret:    函数返回值</li>
</ul>
</li>
</ul>
</li>
<li><p>文件事件:</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct inotify_event &#123;</span><br><span class="line"></span><br><span class="line">__s32 wd; /* watch descriptor */</span><br><span class="line"></span><br><span class="line">__u32 mask; /* watch mask */</span><br><span class="line"></span><br><span class="line">__u32 cookie; /* cookie to synchronize two events */</span><br><span class="line"></span><br><span class="line">__u32 len; /* length (including nulls) of name */</span><br><span class="line"></span><br><span class="line">char name[0]; /* stub for possible name */</span><br><span class="line"></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure></li>
<li><p>size_t len &#x3D; read(fd, buf, BUF_LEN);</p>
<ul>
<li>参数介绍:<ul>
<li>buf:    inotify_event结构的数组指针</li>
<li>BUF_LEN:    指定要读取的总长度</li>
</ul>
</li>
</ul>
</li>
<li><p>可以在函数 inotify_init() 返回的文件描述符 fd 上使用 select() 或poll(), 也可以在 fd 上使用 ioctl 命令 FIONREAD 来得到当前队列的长度。</p>
</li>
<li><p>close(fd)将删除所有添加到 fd 中的 watch 并做必要的清理</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yamamic.github.io/2023/07/29/inotify/" data-id="clks0noi00004cwpzemdm3tuk" data-title="inotify" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-unix域协议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/29/unix%E5%9F%9F%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time class="dt-published" datetime="2023-07-29T06:45:24.000Z" itemprop="datePublished">2023-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/29/unix%E5%9F%9F%E5%8D%8F%E8%AE%AE/">unix域协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><p>概念:    Unix域协议并不是一个实际的协议族,它只是在同一台主机上进行客户-服务器通信时,使用与在不同主机上的客户和服务器间通信时相同的API(套接口或XTI)的一种方法。当客户和服务器在同一台主机上时,Unix域协议是IPC通信方式的一种替代品。</p>
<ul>
<li>Unix域协议提供了两种类型的套接口:    字节流套接口和数据报套接口</li>
</ul>
</li>
<li><p>   优点:    </p>
<ol>
<li>比起TCP协议通常要更快;</li>
<li>支持在同一台主机上的不同进程之间传递描述符;</li>
<li>支持传递客户端凭证。</li>
</ol>
</li>
<li><pre><code>Unix域socket地址结构:    
</code></pre>
<ul>
<li>   头文件:    &lt;sys&#x2F;un.h&gt;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   struct sockaddr_un</span><br><span class="line">&#123;</span><br><span class="line">		sa_family_t sun_family;	</span><br><span class="line">		char sun_path[108];	/*pathname */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用方式:    </p>
<ul>
<li><p>   说明:和tcp&#x2F;udp套接字的方式类似,只需要将协议族替换为AF_LOCAL或者AF_UNIX,然后将地址替换为sockaddr_un即可。</p>
<ul>
<li>   要注意的是bind绑定的不是ip地址,而是用一个文件路径来作为地址(绑定的路径应使用绝对路径,避免相对路径的解析依赖	调用者的当前路径)POSIX声称使用相对路径绑定到uds将导致不可预计的结果</li>
</ul>
</li>
<li><p>   connect:    </p>
<ol>
<li>调用connect连接一个uds涉及的权限检查等同于调用open以只读模式访问对应路径。</li>
<li>unix域字节流套接字与TCP套接字类似,它们都提供无记录边界的字节流接口。</li>
<li>如果对一个uds进行connect时发现监听套接字的队列已满,调用会立即返回一个ECONNECTREFUSED错误;<br> 而TCP监听套接字在队列满时则会忽略新到达的SYNC,进而连接发起端发起端进行重试。</li>
<li>unix域数据报套接字与UDP套接字类似,它们都提供保留记录边界的不可靠的数据报服务。</li>
<li>在未绑定的uds上发送数据不会自动为其绑定一个路径,这一点不同于UDP套接字:    在一个未绑定的UDP套接字上发送数据会为其<br> 绑定一个临时端口。这意味着除非数据报发送端已经绑定到一个路径,否则数据报接收端无法发回应答数据报。<br> 类似的,对于uds的connect调用不会为其绑定一个路径,这一点不同于TCP&#x2F;UDP</li>
</ol>
</li>
</ul>
</li>
<li><p>   应用场景:    </p>
<ul>
<li>   本机通讯:    当我们需要在本机通信时,可以使用uds来代替本地回环接口。uds相比TCP&#x2F;UDP套接字性能会更好,因为它不需要经过网络协议栈,省去了各种解析和应答等步骤,而是直接在内核拷贝传递数据。比如最近很热的service mesh,业务进程和sidecar就可以通过uds来通信。</li>
<li>   传递描述符:    unix系统提供了用于从一个进程向其他任意进程传递描述符的方式,而这两个进程不需要有任何亲缘关系。这种技术要求在两个进程之间创建一个uds,然后使用sendmsg通过这个uds发送特殊结构的消息。这个特殊的消息会由内核处理,把打开的描述符从发送进程传递到接收进程。<ul>
<li>   步骤:    <ol>
<li>创建一个字节流或数据报的uds。这可以通过调用socketpair然后父子进程之间的连接;也可以使用套接字API。通常建议使用字节流套接字而不是数据报套接字,因为使用数据报套接字并没有什么好处,反而还存在数据报被丢弃的可能。</li>
<li>发送端打开描述符。uds可以传递各种类型的描述符,而不是仅包括文件描述符。</li>
<li>发送端进程创建一个msghdr的结构,其中含有待传递的描述符,然后调用sendmsg将其发送出去。发送一个描述符会使其引用计数加一。</li>
<li>接收端进程调用recvmsg在创建的uds上接收描述符。这个过程会在接收进程创建一个新的描述符,然后将其指向和发送进程发送的描述符指向的同一个内核文件选项。所以接收端收到的描述符不同于发送端发送端描述符是很正常的</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* [XSI] Message header for recvmsg and sendmsg calls.</span><br><span class="line">* Used value-result for recvmsg, value only for sendmsg.</span><br><span class="line">*/</span><br><span class="line">struct msghdr &#123;</span><br><span class="line">    void		*msg_name;	/* [XSI] optional address */</span><br><span class="line">    socklen_t	msg_namelen;	/* [XSI] size of address */</span><br><span class="line">    struct		iovec *msg_iov;	/* [XSI] scatter/gather array */</span><br><span class="line">    int		msg_iovlen;	/* [XSI] # elements in msg_iov */</span><br><span class="line">    void		*msg_control;	/* [XSI] ancillary data, see below */</span><br><span class="line">    socklen_t	msg_controllen;	/* [XSI] ancillary data buffer len */</span><br><span class="line">    int		msg_flags;	/* [XSI] flags on received message */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>验证发送者的身份:    	传递用户凭证。</li>
</ul>
</li>
<li><p>例子:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_un srv_addr,addr2;</span><br><span class="line">    //先调用socket创建套接字</span><br><span class="line">    sockfd = socket(AF_LOCAL, SOCK_STREAM, 0);</span><br><span class="line">    //对已存在的路径进行bind会导致失败,所以需要预先unlink删除文件</span><br><span class="line">    unlink(pathname);</span><br><span class="line">    //初始化地址结构</span><br><span class="line">    bzero(&amp;srv_addr,sizeof(srv_addr));</span><br><span class="line">    //设置协议族为AF_LOCAL或AF_UNIX</span><br><span class="line">    srv_addr.sun_family = AF_LOCAL;</span><br><span class="line">    //设置地址的文件路径</span><br><span class="line">    strcpy(srv_addr.sun_path,pathname);</span><br><span class="line">    //绑定文件路径</span><br><span class="line">    bind(sockfd, (struct sockaddr*)&amp;srv_addr,sizeof(srv_addr));</span><br><span class="line">    //开始监听</span><br><span class="line">    listen(sockfd, 1);</span><br><span class="line">    </span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        connfd = accept(sockfd, (struct sockaddr*)&amp;addr2,sizeof(addr2));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line">    客户端connect:</span><br></pre></td></tr></table></figure>
<pre><code>struct sockaddr_un cliaddr;
cliaddr.sun_family = AF_LOCAL;
strcpy(cliaddr.sun_path, pathname);
connect(connnfd, (struct sockaddr*)&amp;cliaddr,sizeof(cliaddr));
</code></pre>
<pre><code>
</code></pre>
</li>
</ul>
<p>socketpair:	socketpair函数可以创建两个连接起来的unix域套接字<br>    头文件:    	&lt;sys&#x2F;socket.h&gt;<br>    函数原型:    	int socketpair(int family, int type, int protocol, int sockfd[2]);<br>    使用方法:    	family:AF_LOCAL<br>                protocol:0<br>                type:SOCK_STREAM or SOCK_DGRAM<br>                sockfd[2]:新创建的两个套接字描述符作为sockfd[0]和sockfd[1]返回</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yamamic.github.io/2023/07/29/unix%E5%9F%9F%E5%8D%8F%E8%AE%AE/" data-id="clks0noi30006cwpzffpwd2ot" data-title="unix域协议" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">十一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/11/09/DHCP%E5%8D%8F%E8%AE%AE/">DHCP协议</a>
          </li>
        
          <li>
            <a href="/2023/08/25/dns/">dns server</a>
          </li>
        
          <li>
            <a href="/2023/08/18/DHCP%E6%8A%A5%E6%96%87%E5%8F%8A%E5%8D%8F%E8%AE%AE/DHCP%E6%8A%A5%E6%96%87%E5%8F%8A%E5%8D%8F%E8%AE%AE/">DHCP报文及协议</a>
          </li>
        
          <li>
            <a href="/2023/08/09/1905-process/">1905 协议</a>
          </li>
        
          <li>
            <a href="/2023/08/01/vscode%E8%BF%9C%E7%A8%8B%E5%B7%A5%E4%BD%9Ccpu%E5%8D%A0%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%E9%97%AE%E9%A2%98%E4%BF%AE%E6%94%B9/">vscode远程工作cpu占用率过高问题修改</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Kazi Ball<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>